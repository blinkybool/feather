"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[331],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,f=d["".concat(s,".").concat(m)]||d[m]||u[m]||a;return t?r.createElement(f,i(i({ref:n},p),{},{components:t})):r.createElement(f,i({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},76647:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var r=t(87462),o=(t(67294),t(3905));const a={},i=void 0,l={type:"mdx",permalink:"/feather/",source:"@site/pages/index.md",description:"Roact is great for managing a hierarchy of instances as a function of some underlying state, but when handling tens of thousands of instances, the memory usage becomes a problem.",frontMatter:{}},s=[],c={toc:s};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Roact is great for managing a hierarchy of instances as a function of some underlying state, but when handling tens of thousands of instances, the memory usage becomes a problem."),(0,o.kt)("p",null,"Feather lets you manage instances with the same ",(0,o.kt)("inlineCode",{parentName:"p"},"component + props")," logic as Roact, using the absolute bare minimum amount of memory usage in the virtual tree, while still being performant."),(0,o.kt)("p",null,"The key is to not store any host props in the virtual tree, and allow function components more control over which of their resulting host components get updated."),(0,o.kt)("p",null,"For example, the following curve component draws lines (with parts) between adjacent points along the curve, and uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Feather.DeltaChildren")," key to update only those lines whose props ",(0,o.kt)("em",{parentName:"p"},"would be changed"),", had they been included as children. This differs from ",(0,o.kt)("inlineCode",{parentName:"p"},"Feather.Children"),", which destroys any existing children which are missing from the children table."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local function partCurve(props, oldProps)\n\n    local deltaChildren = table.create(#props.Points)\n\n    local curve = props\n\n    for i=1, #props.Points-1 do\n\n        if\n            not oldProps.Points -- this is the first render\n            or\n            props.Color ~= oldProps.Color\n            or\n            props.Points[i] ~= oldProps.Points[i]\n            or\n            props.Points[i+1] ~= oldProps.Points[i+1] then\n\n            local centre = (curve.Points[i] + curve.Points[i+1])/2\n            local vector = (curve.Points[i] - curve.Points[i+1])\n        \n            deltaChildren[i] = e("Part", {\n        \n                Size = Vector3.new((curve.Points[i] - curve.Points[i+1]).Magnitude, 0.001, curve.Width),\n                Color = curve.Color,\n                CFrame =\n                    CFrame.new(centre.X, 1 + 0.001 * curve.ZIndex, centre.Y)\n                    *\n                    CFrame.Angles(0, -math.atan2(vector.Y, vector.X), 0),\n        \n                Anchored = true,\n            })\n        end\n    end\n\n    return e("Folder", {\n\n        [Feather.DeltaChildren] = deltaChildren\n    })\nend\n')))}p.isMDXComponent=!0}}]);